<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fishbone Diagram Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .fishbone-container {
            width: 100%;
            min-height: 600px;
            height: auto;
            background-color: #f9fafb;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            overflow: hidden;
        }
        .link {
            fill: none;
            stroke: #6b7280;
            stroke-width: 2px;
        }
        .delete-icon {
            cursor: pointer;
            font-size: 14px;
            fill: #ef4444;
            display: none;
        }
        g:hover > .delete-icon {
            display: block;
        }
        .main-cause-group {
            cursor: grab;
        }
        .main-cause-group:active {
            cursor: grabbing;
        }
        .item-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.5rem;
            margin-top: 1rem;
        }
        .editable-text-input {
            width: 100%;
            height: 100%;
            border: 1px solid #3b82f6;
            background-color: white;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            padding: 2px;
            box-sizing: border-box;
        }
        #matrix-modal {
            transition: opacity 0.3s ease-in-out;
        }
        .matrix-table th, .matrix-table td {
            border: 1px solid #d1d5db;
            padding: 0.5rem;
            text-align: center;
        }
        .matrix-table input, .matrix-table select {
            width: 100%;
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
            text-align: center;
        }
        .matrix-table select {
            padding: 0.25rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Fishbone Diagram Generator</h1>
            <p class="text-md text-gray-600 mt-2">Follow the steps to build your diagram. You can drag and drop main causes to reorder them.</p>
             <div class="mt-4">
                <label for="import-json" class="bg-gray-500 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-600 cursor-pointer">
                    Import JSON
                </label>
                <input type="file" id="import-json" class="hidden" onchange="importJSON(event)">
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Panel: Questionnaire -->
            <div class="lg:col-span-1 bg-white p-6 rounded-lg shadow-md flex flex-col">
                <div id="question-panel" class="flex-grow">
                    <!-- Questions will be dynamically inserted here -->
                </div>
                <div id="nav-panel" class="mt-6 pt-6 border-t border-gray-200 flex justify-between items-center">
                    <!-- Navigation buttons will be inserted here -->
                </div>
            </div>

            <!-- Right Panel: Fishbone Diagram -->
            <div class="lg:col-span-2 bg-white p-4 rounded-lg shadow-md">
                <div id="fishbone-diagram" class="fishbone-container">
                    <svg id="fishbone-svg" width="100%" height="100%"></svg>
                </div>
            </div>
        </div>
    </div>
    
    <!-- C&E Matrix Modal -->
    <div id="matrix-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div id="matrix-content" class="bg-white rounded-lg shadow-xl w-full max-w-6xl h-full max-h-[90vh] flex flex-col">
            <!-- Content will be injected here -->
        </div>
    </div>


    <script>
        // --- Data Structure ---
        let fishboneData = {
            problem: "",
            causes: []
        };
        let matrixData = {
            cts: [],
            inputs: [],
            specs: { lower: '', target: '', upper: '' }
        };

        // --- State Management ---
        let currentStep = 0; // 0: problem, 1: mainCauses, 2: subCauses, 3: subSubCauses, 4: finished
        let causeIterator = 0;
        let subCauseIterator = 0;
        const colorPalette = ["#3b82f6", "#10b981", "#ef4444", "#f97316", "#8b5cf6", "#ec4899"];

        // --- DOM Elements ---
        const questionPanel = document.getElementById('question-panel');
        const navPanel = document.getElementById('nav-panel');
        const svg = d3.select("#fishbone-svg");
        const container = document.getElementById('fishbone-diagram');
        
        // --- Drag and Drop Handlers ---
        function dragstarted(event, d) { d3.select(this).raise().style("opacity", 0.7); }
        function dragged(event, d) { /* No visual update needed */ }
        function dragended(event, d) {
            d3.select(this).style("opacity", 1);
            const startIndex = d.index;
            const width = container.clientWidth;
            const tempText = svg.append("text").text(fishboneData.problem).call(wrapText, 120);
            const problemBoxWidth = tempText.node().getBBox().width + 20;
            tempText.remove();
            
            const headX = width - problemBoxWidth - 20;
            const tailX = 50;
            const numCauses = fishboneData.causes.length;
            const causeSpacing = numCauses > 0 ? (headX - tailX - 100) / numCauses : 0;
            
            const dropX = event.x;
            let targetIndex = Math.round((dropX - (tailX + 50)) / causeSpacing);
            targetIndex = Math.max(0, Math.min(numCauses - 1, targetIndex));

            if (startIndex !== targetIndex) {
                const [removed] = fishboneData.causes.splice(startIndex, 1);
                fishboneData.causes.splice(targetIndex, 0, removed);
                drawAndRender();
            }
        }

        // --- D3 Visualization ---
        function drawFishbone() {
            svg.selectAll("*").remove();
            if (!fishboneData.problem && fishboneData.causes.length === 0) return;

            // --- Dynamic Height Calculation ---
            let maxTopExtension = 150;
            let maxBottomExtension = 150;
            fishboneData.causes.forEach((cause, i) => {
                let requiredExtension = 100;
                if (cause.subCauses && cause.subCauses.length > 0) {
                    requiredExtension += cause.subCauses.length * 35;
                    cause.subCauses.forEach(sc => {
                        if (sc.subSubCauses) {
                            requiredExtension += sc.subSubCauses.length * 25;
                        }
                    });
                }
                if (i % 2 === 0) {
                    maxTopExtension = Math.max(maxTopExtension, requiredExtension);
                } else {
                    maxBottomExtension = Math.max(maxBottomExtension, requiredExtension);
                }
            });
            const finalHeight = maxTopExtension + maxBottomExtension + 50;
            svg.attr("height", Math.max(600, finalHeight));
            const midY = maxTopExtension + 25;
            // --- End of Dynamic Height Calculation ---

            const width = container.clientWidth;
            const tailX = 50;
            
            const problemTextNode = svg.append("text").attr("class", "temp-text").text(fishboneData.problem || "Problem").call(wrapText, 120);
            const problemBBox = problemTextNode.node().getBBox();
            problemTextNode.remove();
            const headX = width - problemBBox.width - 40;

            svg.append("line").attr("x1", tailX).attr("y1", midY).attr("x2", headX).attr("y2", midY).attr("class", "link").attr("stroke-width", 3);
            
            const problemGroup = svg.append("g");
            const problemText = problemGroup.append("text").text(fishboneData.problem).attr("fill", "white").style("font-weight", "bold").call(wrapText, 120, 5);
            const textBBox = problemText.node().getBBox();
            problemGroup.insert("rect", "text").attr("x", textBBox.x - 10).attr("y", textBBox.y - 10).attr("width", textBBox.width + 20).attr("height", textBBox.height + 20).attr("fill", "#3b82f6").attr("rx", 5);
            const groupBBox = problemGroup.node().getBBox();
            problemText.attr("x", (groupBBox.width - textBBox.width) / 2 - textBBox.x).attr("y", (groupBBox.height - textBBox.height) / 2 - textBBox.y);
            problemGroup.attr("transform", `translate(${headX}, ${midY - (groupBBox.y + groupBBox.height / 2)})`);
            problemText.on("dblclick", (event) => makeEditable(event.currentTarget, 'problem'));


            const numCauses = fishboneData.causes.length;
            const causeSpacing = numCauses > 0 ? (headX - tailX - 100) / numCauses : 0;
            const drag = d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);

            fishboneData.causes.forEach((cause, i) => {
                const isTop = i % 2 === 0;
                const causeX = tailX + 50 + (i * causeSpacing);
                const causeY = midY;
                
                const branchEndY = midY + (isTop ? -maxTopExtension : maxBottomExtension);
                
                const mainCauseGroup = svg.append("g").attr("class", "main-cause-group").datum({cause: cause, index: i}).call(drag);
                mainCauseGroup.append("line").attr("x1", causeX).attr("y1", causeY).attr("x2", causeX + 120).attr("y2", branchEndY).attr("class", "link").style("stroke", cause.color || '#6b7280');
                const mainCauseText = mainCauseGroup.append("text").text(cause.name).attr("x", causeX + 125).attr("y", branchEndY + (isTop ? -5 : 15)).attr("text-anchor", "start").attr("alignment-baseline", isTop ? "end" : "hanging").style("font-weight", "500").call(wrapText, 150, 4);
                mainCauseText.on("dblclick", (event) => makeEditable(event.currentTarget, 'cause', i));
                mainCauseGroup.append("text").attr("x", causeX + 110).attr("y", branchEndY + (isTop ? 15 : -15)).attr("class", "delete-icon").text("❌").on("click", (e) => { e.stopPropagation(); deleteMainCause(i); });

                if (cause.subCauses && cause.subCauses.length > 0) {
                    const numSubCauses = cause.subCauses.length;
                    cause.subCauses.forEach((subCause, j) => {
                        const fraction = (j + 1) / (numSubCauses + 1);

                        const subCauseBranchStartX = causeX + (120 * fraction);
                        const subCauseBranchStartY = causeY + ((branchEndY - causeY) * fraction);

                        const subCauseLineLength = 50;
                        const subCauseBranchEndX = subCauseBranchStartX + subCauseLineLength;
                        
                        const subCauseGroup = svg.append("g");
                        
                        subCauseGroup.append("line")
                            .attr("x1", subCauseBranchStartX)
                            .attr("y1", subCauseBranchStartY)
                            .attr("x2", subCauseBranchEndX)
                            .attr("y2", subCauseBranchStartY)
                            .attr("class", "link").style("stroke", cause.color || '#6b7280');

                        const subCauseText = subCauseGroup.append("text")
                            .text(subCause.name)
                            .attr("x", subCauseBranchEndX + 5)
                            .attr("y", subCauseBranchStartY + 3)
                            .attr("text-anchor", "start")
                            .attr("alignment-baseline", "middle")
                            .call(wrapText, 100, 3, 12, 9);
                        subCauseText.on("dblclick", (event) => makeEditable(event.currentTarget, 'subCause', i, j));

                        subCauseGroup.append("text")
                            .attr("x", subCauseBranchEndX - 5)
                            .attr("y", subCauseBranchStartY + 18)
                            .attr("class", "delete-icon")
                            .text("❌")
                            .on("click", (e) => { e.stopPropagation(); deleteSubCause(i, j); });

                        if (subCause.subSubCauses) {
                            subCause.subSubCauses.forEach((subSubCause, k) => {
                                const subSubCauseX = subCauseBranchStartX + 15;
                                // --- CORRECTED: Reasons now branch inwards towards the spine ---
                                const subSubCauseY = subCauseBranchStartY + (isTop ? 25 * (k + 1) : -25 * (k + 1));
                                // --- End of correction ---
                                const subSubCauseGroup = svg.append("g");
                                subSubCauseGroup.append("line").attr("x1", subSubCauseX).attr("y1", subSubCauseY).attr("x2", subSubCauseX + 35).attr("y2", subSubCauseY).attr("class", "link").attr("stroke-dasharray", "2,2").style("stroke", cause.color || '#6b7280');
                                const subSubCauseText = subSubCauseGroup.append("text").text(subSubCause.name).attr("x", subSubCauseX + 40).attr("y", subSubCauseY + 3).attr("text-anchor", "start").attr("alignment-baseline", "middle").style("font-style", "italic").call(wrapText, 80, 2, 11, 8);
                                subSubCauseText.on("dblclick", (event) => makeEditable(event.currentTarget, 'subSubCause', i, j, k));
                                subSubCauseGroup.append("text").attr("x", subSubCauseX + 30).attr("y", subSubCauseY + 15).attr("class", "delete-icon").text("❌").on("click", (e) => { e.stopPropagation(); deleteSubSubCause(i, j, k); });
                            });
                        }
                    });
                }
            });
        }

        // --- UI Rendering Logic ---
        function renderUI() {
            let content = '';
            let nav = '';
            
            const backButton = `<button onclick="goBack()" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-md hover:bg-gray-300">Back</button>`;
            const nextButton = (text = 'Next') => `<button onclick="goNext()" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-blue-700">${text}</button>`;
            
            const exportButtons = `
                <div class="flex flex-col gap-2">
                    <button onclick="launchMatrixWizard()" class="w-full bg-purple-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-purple-700 text-sm">Create C&E Matrix</button>
                    <button onclick="exportTextReport()" class="w-full bg-blue-700 text-white font-semibold py-2 px-4 rounded-md hover:bg-blue-800 text-sm">Export Report (for Word)</button>
                    <button onclick="exportSVG()" class="w-full bg-teal-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-teal-700 text-sm">Export SVG (for Visio)</button>
                    <button onclick="exportPNG()" class="w-full bg-sky-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-sky-700 text-sm">Export PNG</button>
                    <button onclick="exportJSON()" class="w-full bg-gray-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-700 text-sm">Export JSON (Backup)</button>
                    <button onclick="exportCSV()" class="w-full bg-green-700 text-white font-semibold py-2 px-4 rounded-md hover:bg-green-800 text-sm">Export CSV (for Excel)</button>
                </div>
            `;

            switch (currentStep) {
                case 0: // Problem
                    content = `
                        <h2 class="text-xl font-semibold text-gray-800 mb-2">Step 1: Define the Problem</h2>
                        <p class="text-sm text-gray-600 mb-4">Define the main problem. This is the "head" of the fish.</p>
                        <textarea id="problem-input" class="block w-full rounded-md border-gray-300 shadow-sm" rows="3" oninput="updateProblem(this.value)">${fishboneData.problem}</textarea>
                    `;
                    nav = `<div class="w-full text-right">${nextButton()}</div>`;
                    break;
                case 1: // Main Causes
                    let mainCausesList = fishboneData.causes.map((c, i) => `<li class="flex items-center justify-between bg-gray-50 p-2 rounded-md"><span>${c.name}</span><button onclick="deleteMainCause(${i})" class="text-red-500 hover:text-red-700 font-bold">&times;</button></li>`).join('');
                    content = `
                        <h2 class="text-xl font-semibold text-gray-800 mb-2">Step 2: Identify Main Causes</h2>
                        <p class="text-sm text-gray-600 mb-4">Add high-level cause categories (the main "bones"). Common examples: People, Processes, Equipment.</p>
                        <div class="flex space-x-2">
                           <input type="text" id="main-cause-input" class="block w-full rounded-md border-gray-300 shadow-sm" placeholder="e.g., People, Equipment" onkeydown="if(event.key==='Enter') addMainCause()">
                           <button onclick="addMainCause()" class="bg-green-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-green-700">Add</button>
                        </div>
                        <ul class="mt-4 space-y-2 item-list">${mainCausesList}</ul>
                    `;
                    nav = `${backButton} ${nextButton('Analyze Sub-Causes &raquo;')}`;
                    break;
                case 2: // Sub-Causes
                    if (fishboneData.causes.length === 0) { goNext(); break; }
                    const cause = fishboneData.causes[causeIterator];
                    let subCausesList = (cause.subCauses || []).map((sc, i) => `<li class="flex items-center justify-between bg-gray-50 p-2 rounded-md"><span>${sc.name}</span><button onclick="deleteSubCause(${causeIterator}, ${i})" class="text-red-500 hover:text-red-700 font-bold">&times;</button></li>`).join('');
                    content = `
                        <h2 class="text-xl font-semibold text-gray-800 mb-2">Step 3: Analyze Sub-Causes</h2>
                        <p class="text-sm text-gray-600 mb-4">For <strong class="text-indigo-600">${cause.name}</strong>, add contributing factors. Ask "Why is this happening?"</p>
                        <div class="flex space-x-2">
                           <input type="text" id="sub-cause-input" class="block w-full rounded-md border-gray-300 shadow-sm" placeholder="e.g., Lack of training" onkeydown="if(event.key==='Enter') addSubCause()">
                           <button onclick="addSubCause()" class="bg-green-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-green-700">Add</button>
                        </div>
                        <ul class="mt-4 space-y-2 item-list">${subCausesList}</ul>
                    `;
                    nav = `${backButton} ${nextButton('Analyze Reasons &raquo;')}`;
                    break;
                case 3: // Sub-Sub-Causes (Reasons)
                    if (fishboneData.causes.length === 0) { goBack(); break; }
                    const currentCause = fishboneData.causes[causeIterator];
                    if (!currentCause.subCauses || currentCause.subCauses.length === 0) { goNext(); break; }
                    const subCause = currentCause.subCauses[subCauseIterator];
                    let reasonsList = (subCause.subSubCauses || []).map((ssc, i) => `<li class="flex items-center justify-between bg-gray-50 p-2 rounded-md"><span>${ssc.name}</span><button onclick="deleteSubSubCause(${causeIterator}, ${subCauseIterator}, ${i})" class="text-red-500 hover:text-red-700 font-bold">&times;</button></li>`).join('');
                    content = `
                        <h2 class="text-xl font-semibold text-gray-800 mb-2">Step 4: Analyze Reasons</h2>
                        <p class="text-sm text-gray-600 mb-2">For <strong class="text-indigo-600">${subCause.name}</strong>, add specific root causes. Ask "Why?" again.</p>
                        <p class="text-sm text-gray-600 mb-4">Main Cause: <strong class="text-indigo-600">${currentCause.name}</strong></p>
                        <div class="flex space-x-2">
                           <input type="text" id="sub-sub-cause-input" class="block w-full rounded-md border-gray-300 shadow-sm" placeholder="e.g., Documentation is unclear" onkeydown="if(event.key==='Enter') addSubSubCause()">
                           <button onclick="addSubSubCause()" class="bg-green-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-green-700">Add</button>
                        </div>
                        <ul class="mt-4 space-y-2 item-list">${reasonsList}</ul>
                    `;
                    nav = `${backButton} ${nextButton('Next Sub-Cause')}`;
                    break;
                case 4: // Finished
                    content = `
                        <div class="text-center p-4 border border-dashed border-green-500 rounded-lg bg-green-50">
                            <h3 class="text-lg font-semibold text-green-800">Diagram Complete!</h3>
                            <p class="text-green-700 mt-2">Diagram complete. Review for root causes. You can still go back to edit any step.</p>
                        </div>
                        <div class="mt-4">${exportButtons}</div>
                        `;
                    nav = `${backButton}`;
                    break;
            }
            questionPanel.innerHTML = content;
            navPanel.innerHTML = nav;
        }

        // --- Navigation ---
        function goNext() {
            if (currentStep === 1 && fishboneData.causes.length === 0) {
                currentStep = 4;
            } else if (currentStep === 2) {
                currentStep++; // Move to sub-sub-causes
                subCauseIterator = 0;
            } else if (currentStep === 3) {
                subCauseIterator++;
                const cause = fishboneData.causes[causeIterator];
                if (!cause || !cause.subCauses || subCauseIterator >= cause.subCauses.length) {
                    causeIterator++;
                    subCauseIterator = 0;
                    if (causeIterator >= fishboneData.causes.length) {
                        currentStep++; // All done, go to finished
                        causeIterator = 0;
                    } else {
                        currentStep = 2; // Go to next main cause's sub-causes
                    }
                }
            } else {
                currentStep++;
            }
            if(currentStep > 4) currentStep = 4;
            renderUI();
        }

        function goBack() {
             if (currentStep === 3) {
                subCauseIterator--;
                if (subCauseIterator < 0) {
                    currentStep--; // Back to sub-causes of the same main cause
                    subCauseIterator = fishboneData.causes[causeIterator]?.subCauses?.length - 1 || 0;
                }
            } else if (currentStep === 2) {
                causeIterator--;
                if (causeIterator < 0) {
                    currentStep--; // Back to main causes
                    causeIterator = 0;
                }
            } else if (currentStep === 4) { // From Finished
                currentStep = (fishboneData.causes.length > 0) ? 3 : 1; // Go to last step with data
                causeIterator = fishboneData.causes.length - 1;
                const lastCause = fishboneData.causes[causeIterator];
                subCauseIterator = lastCause && lastCause.subCauses ? lastCause.subCauses.length - 1 : 0;
            }
            else {
                currentStep--;
            }
            if(currentStep < 0) currentStep = 0;
            renderUI();
        }

        // --- Data Logic ---
        function updateProblem(text) { fishboneData.problem = text; drawFishbone(); }
        
        function addMainCause() {
            const input = document.getElementById('main-cause-input');
            if (input && input.value.trim()) {
                const newCause = {
                    name: input.value.trim(),
                    subCauses: [],
                    color: colorPalette[fishboneData.causes.length % colorPalette.length]
                };
                fishboneData.causes.push(newCause);
                drawAndRender();
                document.getElementById('main-cause-input')?.focus();
            }
        }
        
        function addSubCause() {
            const input = document.getElementById('sub-cause-input');
            if (input && input.value.trim()) {
                const cause = fishboneData.causes[causeIterator];
                if (!cause.subCauses) cause.subCauses = [];
                cause.subCauses.push({ name: input.value.trim(), subSubCauses: [] });
                drawAndRender();
                document.getElementById('sub-cause-input')?.focus();
            }
        }

        function addSubSubCause() {
            const input = document.getElementById('sub-sub-cause-input');
             if (input && input.value.trim()) {
                const subCause = fishboneData.causes[causeIterator].subCauses[subCauseIterator];
                if (!subCause.subSubCauses) subCause.subSubCauses = [];
                subCause.subSubCauses.push({ name: input.value.trim() });
                drawAndRender();
                document.getElementById('sub-sub-cause-input')?.focus();
            }
        }

        // --- Deletion Logic ---
        function deleteMainCause(index) {
            fishboneData.causes.splice(index, 1);
            if (causeIterator >= fishboneData.causes.length) {
                causeIterator = Math.max(0, fishboneData.causes.length - 1);
            }
            drawAndRender();
        }
        function deleteSubCause(mainIndex, subIndex) {
            fishboneData.causes[mainIndex].subCauses.splice(subIndex, 1);
            if (subCauseIterator >= fishboneData.causes[mainIndex].subCauses.length) {
                subCauseIterator = Math.max(0, fishboneData.causes[mainIndex].subCauses.length - 1);
            }
            drawAndRender();
        }
        function deleteSubSubCause(mainIndex, subIndex, subSubIndex) {
            fishboneData.causes[mainIndex].subCauses[subIndex].subSubCauses.splice(subSubIndex, 1);
            drawAndRender();
        }

        // --- Utility Functions ---
        function drawAndRender() {
            drawFishbone();
            renderUI();
        }
        
        function getSVGString() {
            const svgEl = document.getElementById('fishbone-svg');
            const svgClone = svgEl.cloneNode(true);
            
            d3.select(svgClone).selectAll('.delete-icon').remove();

            svgClone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            const styleEl = document.createElement('style');
            styleEl.textContent = `
                .link { fill: none; stroke: #6b7280; stroke-width: 2px; }
                text { font-family: 'Inter', sans-serif; }
            `;
            svgClone.prepend(styleEl);
            const serializer = new XMLSerializer();
            return serializer.serializeToString(svgClone);
        }

        function exportSVG() {
            const svgString = getSVGString();
            const blob = new Blob([svgString], {type: "image/svg+xml"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "fishbone-diagram.svg";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function exportPNG() {
            const svgString = getSVGString();
            const svgEl = document.getElementById('fishbone-svg');
            const width = svgEl.clientWidth;
            const height = svgEl.clientHeight;

            const img = new Image();
            const blob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
            const url = URL.createObjectURL(blob);

            img.onload = function() {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#f9fafb'; // Set background color
                ctx.fillRect(0, 0, width, height);
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);

                const pngUrl = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = pngUrl;
                link.download = 'fishbone-diagram.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };
            img.src = url;
        }

        function exportPDF() {
            const { jsPDF } = window.jspdf;
            const svgString = getSVGString();
            const svgEl = document.getElementById('fishbone-svg');
            const width = svgEl.clientWidth;
            const height = svgEl.clientHeight;

            const img = new Image();
            const blob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
            const url = URL.createObjectURL(blob);

            img.onload = function() {
                const canvas = document.createElement('canvas');
                const scale = 2;
                canvas.width = width * scale;
                canvas.height = height * scale;
                const ctx = canvas.getContext('2d');
                ctx.scale(scale, scale);
                ctx.fillStyle = '#f9fafb';
                ctx.fillRect(0, 0, width, height);
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);
                
                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'px',
                    format: [width, height]
                });
                pdf.addImage(imgData, 'PNG', 0, 0, width, height);
                pdf.save("fishbone-diagram.pdf");
            };
            img.src = url;
        }

        function exportJSON() {
            const jsonString = JSON.stringify(fishboneData, null, 2);
            const blob = new Blob([jsonString], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "fishbone-data.json";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function exportTextReport() {
            let report = `Problem/Effect: ${fishboneData.problem}\n\n`;

            fishboneData.causes.forEach((cause, i) => {
                report += `Category ${i + 1}: ${cause.name}\n\n`;

                if (cause.subCauses && cause.subCauses.length > 0) {
                    cause.subCauses.forEach(subCause => {
                        report += `    Primary Cause: ${subCause.name}\n\n`;

                        if (subCause.subSubCauses && subCause.subSubCauses.length > 0) {
                            report += `        Root Causes:\n\n`;
                            subCause.subSubCauses.forEach(reason => {
                                report += `            - ${reason.name}\n`;
                            });
                            report += `\n`;
                        }
                    });
                }
                report += `\n`;
            });

            const blob = new Blob([report], {type: "text/plain;charset=utf-8"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "fishbone-report.txt";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function exportCSV() {
            let csvContent = "data:text/csv;charset=utf-8,Category,Primary Cause,Root Cause\n";
            fishboneData.causes.forEach(cause => {
                if (cause.subCauses && cause.subCauses.length > 0) {
                    cause.subCauses.forEach(subCause => {
                        if (subCause.subSubCauses && subCause.subSubCauses.length > 0) {
                            subCause.subSubCauses.forEach(reason => {
                                csvContent += `"${cause.name}","${subCause.name}","${reason.name}"\n`;
                            });
                        } else {
                            csvContent += `"${cause.name}","${subCause.name}",""\n`;
                        }
                    });
                } else {
                    csvContent += `"${cause.name}","",""\n`;
                }
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "fishbone-export.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function importJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    // Basic validation
                    if (importedData.problem !== undefined && Array.isArray(importedData.causes)) {
                        fishboneData = importedData;
                        currentStep = 0;
                        causeIterator = 0;
                        subCauseIterator = 0;
                        drawAndRender();
                    } else {
                        alert("Invalid JSON file format.");
                    }
                } catch (error) {
                    alert("Error parsing JSON file: " + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        function makeEditable(target, type, i1, i2, i3) {
            const textElement = d3.select(target);
            const parentGroup = d3.select(target.parentNode);
            const textData = textElement.text();
            
            const { x, y, width, height } = target.getBBox();

            textElement.style('display', 'none');

            const foreignObject = parentGroup.append('foreignObject')
                .attr('x', x)
                .attr('y', y)
                .attr('width', Math.max(100, width))
                .attr('height', Math.max(20, height) * 2)
                .append('xhtml:div')
                .style('width', '100%')
                .style('height', '100%');
            
            const input = foreignObject.append('textarea')
                .attr('class', 'editable-text-input')
                .text(textData)
                .on('blur', function() {
                    const newValue = this.value;
                    updateData(newValue, type, i1, i2, i3);
                    textElement.style('display', null);
                    foreignObject.remove();
                    drawAndRender();
                })
                .on('keydown', function(event) {
                    if (event.key === 'Enter' && !event.shiftKey) {
                        event.preventDefault();
                        this.blur();
                    }
                });
            
            input.node().focus();
            input.node().select();
        }

        function updateData(newValue, type, i1, i2, i3) {
            if (!newValue.trim()) return; // Don't update if empty
            switch(type) {
                case 'problem': fishboneData.problem = newValue; break;
                case 'cause': fishboneData.causes[i1].name = newValue; break;
                case 'subCause': fishboneData.causes[i1].subCauses[i2].name = newValue; break;
                case 'subSubCause': fishboneData.causes[i1].subCauses[i2].subSubCauses[i3].name = newValue; break;
            }
        }

        function wrapText(text, width, maxLines = 10, initialFontSize = 12, minFontSize = 8) {
            text.each(function () {
                const textElement = d3.select(this);
                const words = textElement.text().split(/\s+/).reverse();
                let word;
                let line = [];
                const lineHeight = 1.1; // ems
                const x = textElement.attr("x") || 0;
                const y = textElement.attr("y") || 0;
                
                let currentFontSize = initialFontSize;

                while (currentFontSize >= minFontSize) {
                    textElement.style('font-size', `${currentFontSize}px`);
                    let tspan = textElement.text(null).append("tspan").attr("x", x).attr("y", y);
                    
                    let tempWords = [...words];
                    let lineCount = 1;

                    while (word = tempWords.pop()) {
                        line.push(word);
                        tspan.text(line.join(" "));
                        if (tspan.node().getComputedTextLength() > width) {
                            line.pop();
                            tspan.text(line.join(" "));
                            line = [word];
                            tspan = textElement.append("tspan").attr("x", x).attr("dy", `${lineHeight}em`).text(word);
                            lineCount++;
                        }
                    }

                    if (lineCount <= maxLines) {
                        break; 
                    } else {
                        currentFontSize--; 
                    }
                }
            });
        }

        // --- C&E Matrix Functions ---
        function launchMatrixWizard() {
            matrixData.cts = [{ name: fishboneData.problem, importance: 10 }];
            matrixData.inputs = [];
            fishboneData.causes.forEach(c => {
                (c.subCauses || []).forEach(sc => {
                    matrixData.inputs.push({
                        name: sc.name,
                        processStep: '',
                        ratings: {}
                    });
                });
            });
            renderMatrixCtsScreen();
            document.getElementById('matrix-modal').classList.remove('hidden');
        }

        function renderMatrixCtsScreen() {
            const contentEl = document.getElementById('matrix-content');
            let ctsRows = matrixData.cts.map((cts, i) => `
                <tr class="bg-gray-50">
                    <td class="p-2 border">${i === 0 ? 'Primary Y' : `Other ${i+1}`}</td>
                    <td class="p-2 border"><input type="text" value="${cts.name}" class="w-full p-1" oninput="matrixData.cts[${i}].name = this.value"></td>
                    <td class="p-2 border"><input type="number" value="${cts.importance}" class="w-full p-1" min="1" max="10" oninput="matrixData.cts[${i}].importance = this.value"></td>
                    <td class="p-2 border">${i > 0 ? `<button class="text-red-500 font-bold" onclick="removeCts(${i})">&times;</button>` : ''}</td>
                </tr>
            `).join('');

            contentEl.innerHTML = `
                <div class="p-6 border-b">
                    <h2 class="text-2xl font-bold">C&E Matrix - Step 1: Define Metrics</h2>
                    <p class="text-gray-600 mt-1">Define the outputs (Critical to Satisfaction metrics) and their importance to the customer (1-10).</p>
                </div>
                <div class="p-6 overflow-y-auto flex-grow">
                    <table class="w-full border-collapse">
                        <thead><tr class="bg-gray-100">
                            <th class="p-2 border">#</th><th class="p-2 border">CTS (Critical to Satisfaction)</th><th class="p-2 border">Importance Rating</th><th class="p-2 border"></th>
                        </tr></thead>
                        <tbody>${ctsRows}</tbody>
                    </table>
                    <div class="mt-4 flex gap-2">
                        <button class="bg-blue-500 text-white px-4 py-2 rounded" onclick="addCts()">+ Add CTS</button>
                        <input id="custom-cts-input" type="text" class="border rounded p-1 flex-grow" placeholder="Or type a custom metric and add">
                    </div>
                </div>
                <div class="p-6 border-t flex justify-between">
                    <button class="bg-gray-500 text-white px-4 py-2 rounded" onclick="closeMatrix()">Cancel</button>
                    <button class="bg-green-600 text-white px-4 py-2 rounded" onclick="renderMatrixSpecsScreen()">Next: Define Specs &raquo;</button>
                </div>
            `;
        }
        
        function addCts() {
            const customInput = document.getElementById('custom-cts-input');
            let newCtsName = customInput.value.trim();
            if (!newCtsName) {
                const defaultOptions = ["Cost", "Safety", "Availability", "Reliability"];
                newCtsName = defaultOptions.find(opt => !matrixData.cts.some(cts => cts.name === opt)) || "New Metric";
            }
            matrixData.cts.push({ name: newCtsName, importance: 5 });
            renderMatrixCtsScreen();
        }

        function removeCts(index) {
            matrixData.cts.splice(index, 1);
            renderMatrixCtsScreen();
        }

        function renderMatrixSpecsScreen() {
            const contentEl = document.getElementById('matrix-content');
            contentEl.innerHTML = `
                <div class="p-6 border-b">
                    <h2 class="text-2xl font-bold">C&E Matrix - Step 2: Define Specs</h2>
                    <p class="text-gray-600 mt-1">Enter the specification limits for your primary problem.</p>
                </div>
                <div class="p-6 flex-grow space-y-4">
                    <div>
                        <label class="block font-medium text-gray-700">Lower Spec:</label>
                        <input id="lower-spec" type="text" class="w-full mt-1 p-2 border rounded" value="${matrixData.specs.lower}">
                    </div>
                    <div>
                        <label class="block font-medium text-gray-700">Target:</label>
                        <input id="target-spec" type="text" class="w-full mt-1 p-2 border rounded" value="${matrixData.specs.target}">
                    </div>
                    <div>
                        <label class="block font-medium text-gray-700">Upper Spec:</label>
                        <input id="upper-spec" type="text" class="w-full mt-1 p-2 border rounded" value="${matrixData.specs.upper}">
                    </div>
                </div>
                <div class="p-6 border-t flex justify-between">
                    <button class="bg-gray-500 text-white px-4 py-2 rounded" onclick="renderMatrixCtsScreen()">Back</button>
                    <button class="bg-green-600 text-white px-4 py-2 rounded" onclick="saveSpecsAndProceed()">Next: Rate Causes &raquo;</button>
                </div>
            `;
        }

        function saveSpecsAndProceed() {
            matrixData.specs.lower = document.getElementById('lower-spec').value;
            matrixData.specs.target = document.getElementById('target-spec').value;
            matrixData.specs.upper = document.getElementById('upper-spec').value;
            renderMatrixInputsScreen();
        }

        function renderMatrixInputsScreen() {
             const contentEl = document.getElementById('matrix-content');
             let header = matrixData.cts.map(cts => `<th class="p-1 border transform -rotate-45 h-24 w-16">${cts.name}</th>`).join('');
             let importanceRow = matrixData.cts.map(cts => `<td class="p-2 border font-bold">${cts.importance}</td>`).join('');
             
             let inputRows = matrixData.inputs.map((input, i) => {
                let ratingCells = matrixData.cts.map((_, j) => {
                    const ratingValue = input.ratings[j] || 0;
                    const options = [0, 1, 3, 9];
                    const optionsHtml = options.map(opt => `<option value="${opt}" ${ratingValue == opt ? 'selected' : ''}>${opt}</option>`).join('');
                    return `<td class="p-1 border"><select class="w-16 bg-transparent border-none text-center" onchange="updateMatrixRating(${i}, ${j}, this.value)">${optionsHtml}</select></td>`;
                }).join('');

                let total = calculateMatrixRowTotal(i);
                return `
                    <tr>
                        <td class="p-2 border">${i+1}</td>
                        <td class="p-2 border"><input type="text" value="${input.processStep || ''}" oninput="matrixData.inputs[${i}].processStep = this.value"></td>
                        <td class="p-2 border text-left">${input.name}</td>
                        ${ratingCells}
                        <td class="p-2 border font-bold" id="row-total-${i}">${total}</td>
                    </tr>
                `;
             }).join('');

            let totalCols = matrixData.cts.map((_, j) => `<td class="p-2 border font-bold" id="col-total-${j}"></td>`).join('');

             contentEl.innerHTML = `
                <div class="p-6 border-b">
                    <h2 class="text-2xl font-bold">C&E Matrix - Step 3: Rate Causes</h2>
                    <p class="text-gray-600 mt-1">For each cause, enter the Process Step and rate its impact on each CTS metric (0=None, 1=Low, 3=Medium, 9=High).</p>
                </div>
                <div class="p-6 overflow-auto flex-grow">
                    <table class="w-full border-collapse matrix-table text-sm">
                        <thead>
                            <tr>
                                <th class="p-1 border" rowspan="2">#</th>
                                <th class="p-1 border" rowspan="2">Process Step</th>
                                <th class="p-1 border" rowspan="2">Process Input / Cause</th>
                                <th class="p-1 border" colspan="${matrixData.cts.length}">CTS (Critical to Satisfaction)</th>
                                <th class="p-1 border" rowspan="2">Total</th>
                            </tr>
                            <tr>${header}</tr>
                            <tr class="bg-gray-100"><td class="p-2 border font-bold" colspan="3">Importance Rating</td>${importanceRow}<td class="bg-gray-200"></td></tr>
                        </thead>
                        <tbody>${inputRows}</tbody>
                        <tfoot>
                            <tr class="bg-gray-100"><td class="p-2 border font-bold" colspan="3">Total</td>${totalCols}<td class="bg-gray-200"></td></tr>
                        </tfoot>
                    </table>
                </div>
                <div class="p-6 border-t flex justify-between">
                    <button class="bg-gray-500 text-white px-4 py-2 rounded" onclick="renderMatrixSpecsScreen()">Back</button>
                    <div class="flex gap-2">
                        <button class="bg-green-600 text-white px-4 py-2 rounded" onclick="exportMatrixCSV()">Export CSV</button>
                        <button class="bg-sky-600 text-white px-4 py-2 rounded" onclick="exportMatrixPNG()">Export PNG</button>
                        <button class="bg-red-700 text-white px-4 py-2 rounded" onclick="exportMatrixPDF()">Export PDF</button>
                    </div>
                    <button class="bg-red-500 text-white px-4 py-2 rounded" onclick="closeMatrix()">Close</button>
                </div>
             `;
             updateAllMatrixTotals();
        }

        function updateMatrixRating(inputIndex, ctsIndex, value) {
            matrixData.inputs[inputIndex].ratings[ctsIndex] = parseInt(value, 10);
            updateAllMatrixTotals();
        }
        
        function calculateMatrixRowTotal(inputIndex) {
            let total = 0;
            const input = matrixData.inputs[inputIndex];
            matrixData.cts.forEach((cts, j) => {
                total += (input.ratings[j] || 0) * (cts.importance || 0);
            });
            return total;
        }

        function updateAllMatrixTotals() {
            let colTotals = new Array(matrixData.cts.length).fill(0);
            matrixData.inputs.forEach((input, i) => {
                let rowTotal = 0;
                matrixData.cts.forEach((cts, j) => {
                    const rating = input.ratings[j] || 0;
                    const importance = cts.importance || 0;
                    const score = rating * importance;
                    rowTotal += score;
                    colTotals[j] += score;
                });
                document.getElementById(`row-total-${i}`).textContent = rowTotal;
            });
            colTotals.forEach((total, j) => {
                document.getElementById(`col-total-${j}`).textContent = total;
            });
        }

        function closeMatrix() {
            document.getElementById('matrix-modal').classList.add('hidden');
        }

        function exportMatrixCSV() {
            let csv = [];
            let header1 = ['','','', ...matrixData.cts.map(c => `"${c.name}"`), 'Total'];
            csv.push(header1.join(','));
            let header2 = ['#','Process Step','Process Input / Cause', ...matrixData.cts.map(c => c.importance), ''];
            csv.push(header2.join(','));

            matrixData.inputs.forEach((input, i) => {
                let row = [
                    i + 1,
                    `"${input.processStep || ''}"`,
                    `"${input.name}"`,
                    ...matrixData.cts.map((_, j) => input.ratings[j] || 0),
                    calculateMatrixRowTotal(i)
                ];
                csv.push(row.join(','));
            });
            
            csv.push([]);
            csv.push([`"Lower Spec:","${matrixData.specs.lower}"`]);
            csv.push([`"Target:","${matrixData.specs.target}"`]);
            csv.push([`"Upper Spec:","${matrixData.specs.upper}"`]);

            const csvString = csv.join('\n');
            const blob = new Blob([csvString], {type: "text/csv;charset=utf-8,"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "cause-and-effect-matrix.csv";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportMatrixPNG() {
            const matrixEl = document.getElementById('matrix-content');
            html2canvas(matrixEl, { scale: 2 }).then(canvas => {
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/png');
                link.download = 'cause-and-effect-matrix.png';
                link.click();
            });
        }

        function exportMatrixPDF() {
            const { jsPDF } = window.jspdf;
            const matrixEl = document.getElementById('matrix-content');
            
            html2canvas(matrixEl, { scale: 2 }).then(canvas => {
                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'px',
                    format: [canvas.width, canvas.height]
                });
                pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                pdf.save("cause-and-effect-matrix.pdf");
            });
        }


        // --- Initial Load & Other Functions ---
        window.onload = () => {
            drawAndRender();
        };
        window.onresize = () => {
            drawAndRender();
        };
    </script>
</body>
</html>
